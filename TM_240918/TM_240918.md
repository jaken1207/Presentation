---
marp: true
theme: default
_class: lead
paginate: true
backgroundColor:
backgroundImage: url('https://marp.app/assets/hero-background.svg')

footer: 2024/09/18
---

<!--
headingDivider: 1
-->

# _Thorough explanation of React Server Component(RSC)_

~Server Component, Server Action, Directive~

# _Summary_

<!--
header: "*Summary*"
-->

![bg right:40%](image.png)

#

SSR はページ全体の HTML を事前に生成し、それを高速でクライアント（ブラウザ）に返すことで、「コンテンツの初回描画速度の向上」と「SEO の向上」を図っているアプローチ。

一方、**React Server Components はサーバーだけで完結できるコンポーネントはサーバーで効率よく処理を済ますことで、「UX の向上」と「サービスの安全性向上」を図っている新たな機能。**

# _Introduction_

<!--
header: "*Introduction*"
-->

![bg right:40%](image-1.png)

#

## _What is React Server Component ( RSC )_

React v18 （22 年 3 月）正式リリースの**React の新しいアーキテクチャ**。

Next.js v13.4（23 年 5 月） で Stable になった App Router では、RSC がふんだんに用いて構築されている。

RSC には、サーバコンポーネント、サーバアクション、ディレクティブなどの新しい概念が登場する。

# _Problems with CSR & SSR_

<!--
header: "*Problems with CSR & SSR*"
-->

![bg right:40%](image-2.png)

#

## _CSR (React.js)_

1. クライアントからリクエストが送られる
2. サーバーから**空の HTML と共に、CSS、バンドル JS** が送信される
3. JS を実行して初期レンダリング
4. 必要なデータは API を叩いてフェッチする
5. データ取得後、際レンダリング

#

```jsx
<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
```

#

![bg 70% ](image-6.png)

#

### _Problems_

CSR には JS バンドルが大きく、UI の初期表示に時間がかかる

#

## _SSR (Next.js)_

1. クライアントからリクエストが送られる
2. 初期表示に必要なデータをサーバー側で API コール
3. API からのレスポンスによりデータを取得
4. **サーバー側でレンダリングを行い、HTML を生成**
5. HTML、CSS、**ハイドレーション用 JS** をクライアントに送信
6. クライアントは HTML を表示し、ロードした JS を実行してハイドレードする

#

### ※注意

**Next.js をはじめとするフレームワークによって、サーバー側でのデータ取得を可能**にしている。React ライブラリはクライアントサイドでのデータフェッチしかできない。

getServerSideProps はサーバー上で実行される。この関数が実行された結果が props としてコンポーネントに渡り、プリレンダリングが開始する。

#

```jsx
// pages/products.js
import axios from "axios";

function Products({ products }) {
  return (
    <div>
      <h1>Available Products</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>{product.name}</li>
        ))}
      </ul>
    </div>
  );
}

export async function getServerSideProps() {
  const res = await axios.get("https://api.example.com/products");
  const products = res.data;
  return {
    props: { products }, // will be passed to the page component as props
  };
}

export default Products;
```

#

![bg 70%](image-7.png)

#

### _Problems_

- ページ単位という制限
  - データ取得などが原因でサーバー側の処理が重くなると、プリレンダリングに時間がかかる。
- SSR 手法が標準化されていない
  - PreRendering はあくまでフレームワークの技術であるため、Next.js、Gatsby、Remix などのフレームワークがそれぞれ独自の方法を採用している。
- 常にクライアント上でハイドレーションを行う
  - SSR を使用しても、最終的にはクライアント上で JS によるハイドレーションが必要

# _What is React Server Component ( RSC )_

![bg right:40%](image-3.png)

<!--
header: "*What is React Server Component ( RSC )*"
-->

#

React Server Component（RSC）とは、**React コンポーネントのレンダリングプロセスにおけるアーキテクチャ**（基本設計概念）で、CSR や SSR といったレンダリング手法の問題点を解決するために誕生。

RSC では、**_ServerComponent（SC）_** という新たな概念のコンポーネントが登場。
「クライアントでレンダリングされるコンポーネント」と「サーバーでレンダリングされるコンポーネント」の区別ができるようになり、一つのページに CC と SC が混在するようになる。（下図）

#

![bg 70%](image-8.png)

#

## _Background_

<!--
header: "*What is React Server Component ( RSC ) > Background*"
-->

RSC の誕生背景として、サーバーで生成できるコードはクライアントに送らずサーバーで完結した方が良いという考え方がある。

#

## _Image of processing_

<!--
header: "*What is React Server Component ( RSC ) > Image of processing*"
-->

#

SC では、以下のようにコンポーネント上から**直接外部の API のデータを取得してレンダリングすることが可能**で、**コンポーネント単位でのデータ取得＆レンダリング**をサーバー側で行うことができる。
つまり、**getServerSideProps や getStaticProps を使わなくなる。**

#

```jsx
// RSC登場前
// Next.jsのサーバーサイドフェッチ（getServerSideProps）
import React from "react";

export default function PostList({ posts }) {
  return (
    <div>
      <h1>投稿一覧</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <a href={post.url}>{post.title}</a>
          </li>
        ))}
      </ul>
    </div>
  );
}

// サーバーサイドでデータをフェッチするための関数
export async function getServerSideProps() {
  const res = await fetch("https://example.com/posts");
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}
```

#

```jsx
// RSC登場後
export default async function ServerComponent() {
  const res = await fetch("https://example.com/posts");
  const posts = await res.json();

  return (
    <div>
      <h1>投稿一覧</h1>
      <ul>
        {posts.map(() => (
          <li>
            <a href={post.url}>{post.title}</a>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

#

### _Client Component (CC)_

- **従来の React コンポーネントのこと。**(SC との区別のため)
- **クライアント上でのみ実行されるコンポーネントのことではない**
- SSR の場合、CC はサーバー側でも実行される。**クライアントとサーバーの両方で実行される。**

#

##

#

## _Benefits of RSC_

<!--
header: "*What is React Server Component ( RSC ) > Benefits of RSC*"
-->

#

### 1. データフェッチ

サーバーコンポーネントを使用することで、データリソースの近くでデータ取得を行うことができる。

リクエストの統合:ブラウザ専用の API 以外のデータフェッチはすべて SC で行うことで、サーバーとクライアントのデータ取得がサーバーのみになるため、データリソースへのリクエスト量がまとめられる。

#

2. セキュリティ
   サーバーコンポーネントを使用することで、トークンや API キーなどの機密データとロジックをサーバーだけで完結でき、サービスの安全性が向上
3. キャッシュ
4. バンドルサイズ
5.

# _Difference between SSR and RSC_

![bg right:40%](image-4.png)

<!--
header: "*Difference between SSR and RSC*"
-->

#

#

#

#

#

#

#

#

# 画像を扱う

![bg left:40%](image.png)

#

![bg right:60% contrast:1.5 brightness:1.2](image.png)
![bg 300% contrast:1.2 brightness:1](image.png)

# コードを扱う

```js
console.log("aa");
console.log("xx");
```

#

`puts 'Qiita'`で書くことでインライン表示

#

> 引用

#

<!-- 特定のスライドだけスタイルを変えるときはプロパティの先頭に"_"-->

<!--
_backgroundImage: url('')
_backgroundColor: pink
_color: black
-->

#

#

<!--特定のスライド以降に反映は"_"なし -->
<!--
backgroundImage: url('')
backgroundColor: red
color: white
-->

#
